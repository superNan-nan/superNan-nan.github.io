[{"title":"JAVA集合","slug":"JAVA集合","date":"2021-05-24T14:11:10.000Z","updated":"2021-05-24T14:24:12.355Z","comments":true,"path":"2021/05/24/JAVA集合/","link":"","permalink":"http://example.com/2021/05/24/JAVA%E9%9B%86%E5%90%88/","excerpt":"Java集合详解","text":"Java集合详解 集合大纲单列集合 双列集合 Collection接口方法Collection接口实现类的特点 Collection实现子类可以存放多个元素，每个元素都可以是Object 有些Collection的实现类，可以存放重复的元素（List），有些不可以（Set） 有些Collection的实现类，有些是有序的（List），有些不是有序（Set） Collection接口没有直接的实现子类，是通过它的子接口Set和List来实现的 Collection接口的常用方法 Iterator对象称为迭代器，主要用于遍历Collection集合中的元素，类似于指针，和我们之前用的结果集很像。 所有实现了Collection接口的集合类都有一个iterator（）方法，用以返回一个实现了Iterator接口的对象，即返回一个迭代器。 Iterator的结构是图 Iterator仅用于遍历集合，Iterator本身并不存放对象。迭代器遍历 123456789101112public class Test &#123; public static void main(String[] args) &#123; ArrayList list = new ArrayList(); list.add(1); list.add(2); list.add(4); Iterator iterator = list.iterator(); while (iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; &#125;&#125; for循环增强增强for循环，可以代替Iterator迭代器，特点：增强for循环就是简化版的iterator，本质一样，只能用于遍历集合或数组。 1234567891011public class Test &#123; public static void main(String[] args) &#123; ArrayList list = new ArrayList(); list.add(1); list.add(2); list.add(4); for (Object obj : list)&#123; System.out.println(obj); &#125; &#125;&#125; List接口和常用方法 List集合类中元素是有序的、且可以重复 List集合类的每个元素都有其对应的顺序索引 List容器中的元素都有对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素 常用的接口有ArrayList、LinkedList和VectorArrayList底层结构 ArrayList中维护了一个Object类型的==数组==elementData 当创建ArrayList对象时，如果使用的是无参构造器，则==初始数组容量为0==，==第一次添加，则扩容为10==，如果要再次扩容，则扩容为==1.5==倍。 如果使用的是指定大小的构造器，则==初始数组容量为指定大小==，如果需要扩容，则直接扩容为==1.5==倍Vector底层结构 Vector底层也是一个对象数组 Vector是线程同步的，Vector类的操作方法带有synchronize 在开发中、需要线程同步安全是，考虑使用Vector Vector在扩容时，是2倍，而非是ArrayList的1.5倍LinkedList底层结构 LinkedList实现了==双向链表==和==双端队列==特点 可以添加任意元素（元素可重复），包括null 线程不安全，没有实现同步ArrayList、Vector、LinkedList的区别接口 | 底层结构 | 线程安全 | 效率 | 扩容机制 —- | —–|——–|——–|———–ArrayList | 可变数组 | 线程不安全 | 增删慢、查找快 | 第一次10，满后扩容为1.5倍Vector | 可变数组 | 线程安全 | 效率不高 | 第一次是10，满后扩容为2倍LinkedList | 双向链表 | 线程不安全 | 增删快、查找慢 | 双向链表没有固定的容量，添加直接在链表尾部加上节点即可Set接口和常用方法 无序，没有索引 不允许重复元素，所以最多包含一个null 实现的接口有：HashSet、TreeSetHashSet接口 HashSet的底层是HashMap、HashMap的底层是==数组+链表+红黑树== 第一次添加时，table数组扩容到16，临界值是16*加载因此0.75=12，达到12是，就扩容2倍。 可以存放null值，但是只能有一个null HashSet不保证元素是有序的，取决与hash后，再确定索引的结果 不能有重复元素/对象。HashSet元素不重复的原因==HashSet底层是HashMap。当添加一个元素是，先得到hash值，hash值会转成索引值，找到存储数据表table，看这个索引位置是否已经存放的有元素。如果没有（没有发生哈希碰撞），则直接加入。如果有（发生了哈希碰撞）、则用equals（）方法判断在这个hash值对应的索引的链表上是否有与之相等的节点，如果有则不添加，如果没有则添加到这个链表的结尾。==在Java8中，如果一条链表的元素个数达到了8，并且table的大小不小于64，就会进行树化（红黑树）LinkedHashSet 底层是LinkedHashMap，维护了一个hash表和双向链表 每一个节点有before和after属性，这样可以形成双向链表 在添加一个元素时，先求hash值，再求索引，确定该元素在table的位置，然后将添加的元素加入到双向链表，如果已经存在，则不添加（和HashSet类似） 我们遍历LinkedHashSet也能确保插入顺序和遍历顺序一致Map接口和常用方法 Map与Collection并列存在。用于保存具有映射关系的数据 Map中的key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中 Map中的key不允许重复，原因和HashSet一样，而value是可以重复的 Map的key可以为null，value也可以为null，key只能有一个null，而value为null可以多个。 常用String类作为Map的key key和value之间存在单向一对一关系，即，通过指定的key总能找到对应的valueHashMap HashMap是Map接口使用频率最高的实现类 Has和Map是以key-value对的方式来存储数据 key不能重复，但是值可以重复，允许使用null键和null值 ==添加相同的key，则会覆盖原来的key-value，等同于修改== 与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的 没有实现同步，因此是线程不安全的HashTable接口 存放的元素是键值对 键值都不能为null，否则会抛出NullPointerException 适用方法和HaspMap一致 hashTable是线程安全的","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"适配器设计模式","slug":"适配器设计模式","date":"2021-04-25T14:38:01.000Z","updated":"2021-05-24T14:56:33.976Z","comments":true,"path":"2021/04/25/适配器设计模式/","link":"","permalink":"http://example.com/2021/04/25/%E9%80%82%E9%85%8D%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"适配器","text":"适配器 电脑一般只能读取SD卡，而不能读取TF卡，那么我们想要读取TF卡应该怎么办呢？当然是通过一个读卡器（适配器）来完成我们的需求。那么我们的程序也是一样的，我们需要用的接口，和能使用的接口不一样怎么办呢——通过适配器就可以了。 类适配器 接下来我们就实现一下这个用例。首先我们先看一下我们使用的接口 Computer类12345678910111213package com.yyp.ClassAdapter;public class Computer &#123; public String readSD(SDCard sdCard) &#123; if(sdCard == null) &#123; throw new NullPointerException(&quot;sd card null&quot;); &#125; return sdCard.readSD(); &#125;&#125; 这里只能使用SDCard接口。因此我们要做一个适配器来实现可以使用TFCard接口 SDCard接口1234567package com.yyp.ClassAdapter;public interface SDCard &#123; public String readSD(); public void writeSD();&#125; TFCard接口1234567package com.yyp.ClassAdapter;public interface TFCard &#123; public String readTF(); public void writeTF();&#125; SDCardImpl实现类123456789101112131415package com.yyp.ClassAdapter;public class SDCardImpl implements SDCard&#123; @Override public String readSD() &#123; String msg = &quot;读取SD卡成功&quot;; return msg; &#125; @Override public void writeSD() &#123; System.out.println(&quot;写入SD卡成功&quot;); &#125;&#125; TFCardImpl实现类123456789101112131415package com.yyp.ClassAdapter;public class TFCardImpl implements TFCard&#123; @Override public String readTF() &#123; String msg = &quot;读取TF卡成功&quot;; return msg; &#125; @Override public void writeTF() &#123; System.out.println(&quot;写入TF卡成功&quot;); &#125;&#125; 有了上面的SD和TF类之后，我们就可以编写适配器类了，我们需要的是满足SDCard接口的，因此我们的配置器类直接实现SDCard接口，继承TFCardImpl类即可。 SDAdapterTF1234567891011121314package com.yyp.ClassAdapter;public class SDAdapterTF extends TFCardImpl implements SDCard&#123; @Override public String readSD() &#123; return readTF(); &#125; @Override public void writeSD() &#123; writeTF(); &#125;&#125; 最后我们来测试一下 123456789101112package com.yyp.ClassAdapter;public class Test &#123; public static void main(String[] args) &#123; Computer yyp = new Computer(); System.out.println(&quot;类适配器&quot;); System.out.println(yyp.readSD(new SDCardImpl())); System.out.println(&quot;=====================&quot;); System.out.println(yyp.readSD(new SDAdapterTF())); &#125;&#125; 对象适配器对象适配器和类适配器的区别就是适配器类的不同，对象适配器是面向目标接口的，将要适配的类作为一个对象封装在一个对象里面。 Computer类12345678910111213package com.yyp.ObjectAdapter;public class Computer &#123; public String readSD(SDCard sdCard) &#123; if(sdCard == null) &#123; throw new NullPointerException(&quot;sd card null&quot;); &#125; return sdCard.readSD(); &#125;&#125; SDCard接口1234567package com.yyp.ObjectAdapter;public interface SDCard &#123; public String readSD(); public void writeSD();&#125; TFCard接口1234567package com.yyp.ObjectAdapter;public interface TFCard &#123; public String readTF(); public void writeTF();&#125; SDCardImpl类123456789101112131415package com.yyp.ObjectAdapter;public class SDCardImpl implements SDCard &#123; @Override public String readSD() &#123; String msg = &quot;读取SD卡成功&quot;; return msg; &#125; @Override public void writeSD() &#123; System.out.println(&quot;写入SD卡成功&quot;); &#125;&#125; TFCardImpl类123456789101112131415package com.yyp.ObjectAdapter;public class TFCardImpl implements TFCard &#123; @Override public String readTF() &#123; String msg = &quot;读取TF卡成功&quot;; return msg; &#125; @Override public void writeTF() &#123; System.out.println(&quot;写入TF卡成功&quot;); &#125;&#125; SDAdapterTF类（重点）123456789101112131415161718192021package com.yyp.ObjectAdapter;public class SDAdapterTF implements SDCard &#123; private TFCard tfCard; public SDAdapterTF(TFCard tfCard) &#123; this.tfCard = tfCard; &#125; @Override public String readSD() &#123; return tfCard.readTF(); &#125; @Override public void writeSD() &#123; tfCard.writeTF(); &#125;&#125; 测试123456789101112package com.yyp.ObjectAdapter;public class Test &#123; public static void main(String[] args) &#123; Computer yyp = new Computer(); System.out.println(&quot;对象适配器&quot;); System.out.println(yyp.readSD(new SDCardImpl())); System.out.println(&quot;=====================&quot;); System.out.println(yyp.readSD(new SDAdapterTF(new TFCardImpl()))); &#125;&#125;","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"整数分割","slug":"整数分割","date":"2021-04-04T14:36:58.000Z","updated":"2021-05-24T14:56:00.551Z","comments":true,"path":"2021/04/04/整数分割/","link":"","permalink":"http://example.com/2021/04/04/%E6%95%B4%E6%95%B0%E5%88%86%E5%89%B2/","excerpt":"整数的分割","text":"整数的分割 问题描述先将一个整数分割成若干个整数相加，求多少种分割方法，如443+12+2 2+1+11+1+1+1一种5种 思路我们用到的分治思想，首先我们将问题首先为一个函数F(a,b)表示将a分解为最大值不超过b的式子。因此我们在做的时候，就先将这个递推公式给算出来，那么具体该怎么做呢？首先我们讲一个数分解的时候，肯定是F(a,a)，而这个我们将它分为一个a加上F(a,a-1),这是一种情况，因此F(a,b)=1+F(a,b-1)第二种就是F(a,b)，b&gt;a的时候，我们不可能可以分解出来比a还大的式子，因此这种情况，就变成了F(a,b)=F(a,a)第三种情况就是，a,b其中一个为1的时候，F都是只有一种情况，因此F(a,b)=1第四种情况就是，一般情况。我们将其分两种，一种里面有b，一种里面没有b。而有b的情况就相当于每一个式子一定至少有一个b，我们可以简化为F(a-b,b)，而另一种情况就是F(a,b-1)综上所述： 1 a=1 || b=1 F(a,a) b&gt;aF(a,b)= 1+F(a,b-1) a=b F(a-b,b)+F(a,b-1) 1&lt;a&lt;b 实现123456789101112131415161718192021222324252627282930package suanfa.IntegerDivision;import java.util.Scanner;public class Main &#123; public int f(int n,int m)&#123; if (n==1 || m==1) return 1; else if (n&lt;m)&#123; return f(n,n); &#125;else if (n==m)&#123; return 1+f(n,n-1); &#125;else if (n&gt;m &amp;&amp; m&gt;1) &#123; return f(n, m - 1) + f(n - m, m); &#125;else &#123; return -1; &#125; &#125; public static void main(String[] args) &#123; Main yyp = new Main(); Scanner in = new Scanner(System.in); int n; System.out.println(&quot;请输入要分割的整数&quot;); n = in.nextInt(); System.out.println(yyp.f(n,n)); &#125;&#125; 测试","categories":[],"tags":[]},{"title":"棋盘覆盖","slug":"棋盘覆盖","date":"2021-03-24T14:35:56.000Z","updated":"2021-05-24T14:55:03.531Z","comments":true,"path":"2021/03/24/棋盘覆盖/","link":"","permalink":"http://example.com/2021/03/24/%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96/","excerpt":"棋盘覆盖问题","text":"棋盘覆盖问题 问题描述在一个由2^k * 2^k个方格组成的棋盘中，若恰有一个方格与其他方格不同，称该方格为特殊方格，且称该棋盘为特殊棋盘。显然，特殊方格在棋盘中出现的位置有 4^k种不同的棋盘。我们要用3个方格组成的L型的方块将整个棋盘覆盖掉。 思路首先，我们先考虑22的棋盘，无论特殊方格在哪，另外三个就是一个L型的方块，刚好将整个格棋盘覆盖掉。接下来我们考虑44的棋盘，我们首先将其分为四个22的棋盘，特殊方格必定在其中一个棋盘中，则这个棋盘就是22的棋盘的解决方案，另外三个棋盘，我们各取一个角当做一个L型，剩下的，我想你们也都会了。如下图最终变成了 同理88的棋盘的时候，我们首先将棋盘分为4个4**4的棋盘，其中一个棋盘就是上述44棋盘的解法，另外3个我们继续去一个角，组成L型的方块。如下图然后将每一个4*4的方格都解出来就可以了 实现我们首先就是要构造棋盘，我们用的是二维数组来代替棋盘，我们用同一种数字代表L型的方块 打印整个棋盘12345678public void Println(int a[][])&#123; for (int i=0;i&lt;a.length;i++)&#123; for (int j=0;j&lt;a[i].length;j++)&#123; System.out.printf(&quot;%d\\t&quot;,a[i][j]); &#125; System.out.println(&quot;&quot;); &#125; &#125; 基本的算法123456789101112131415161718192021222324252627282930public void ChessBoard(int tr,int tc,int dr,int dc,int size) &#123;//dc:列,dr:行,为特殊方格的位置 if (size == 1) return; int t = tile++; int s = size / 2; if (dr &lt; tr + s &amp;&amp; dc &lt; tc + s) &#123;//特殊方格在左上角，若果不在左上角的棋盘上，就将左上角的右下角的方块当做特殊方块。 ChessBoard(tr, tc, dr, dc, s); &#125; else &#123; a[tr + s - 1][tc + s - 1] = t; ChessBoard(tr, tc, tr + s - 1, tc + s - 1, s); &#125; if (dc &gt;= tc + s &amp;&amp; dr &lt; tr + s) &#123;//特殊方格在右上角 ChessBoard(tr, tc + s, dr, dc, s); &#125; else &#123; a[tr + s - 1][tc + s] = t; ChessBoard(tr, tc + s, tr + s - 1, tc + s, s); &#125; if (dc &lt; tc + s &amp;&amp; dr &gt;= tr + s) &#123;//特殊方格在左下角 ChessBoard(tr + s, tc, dr, dc, s); &#125; else &#123; a[tr + s][tc + s - 1] = t; ChessBoard(tr + s, tc, tr + s, tc + s - 1, s); &#125; if (dc &gt;= tc + s &amp;&amp; dr &gt;= tr + s) &#123;//特殊方格在右下角 ChessBoard(tr + s, tc + s, dr, dc, s); &#125; else &#123; a[tr + s][tc + s] = t; ChessBoard(tr + s, tc + s, tr + s, tc + s, s); &#125;&#125; 测试123456789101112public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n,i,j; System.out.println(&quot;请输入方格为多大，和特殊方格的坐标，例如16 2 3&quot;); n = in.nextInt(); i = in.nextInt(); j = in.nextInt(); Main yyp = new Main(); yyp.a = new int[n][n]; yyp.ChessBoard(0,0,i-1,j-1,n); yyp.Println(yyp.a); &#125; 全部代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package suanfa.cover;import java.util.Scanner;public class Main &#123; int a[][]; private int tile = 1; public void ChessBoard(int tr,int tc,int dr,int dc,int size) &#123;//dc:列,dr:行,为特殊方格的位置 if (size == 1) return; int t = tile++; int s = size / 2; if (dr &lt; tr + s &amp;&amp; dc &lt; tc + s) &#123;//特殊方格在左上角 ChessBoard(tr, tc, dr, dc, s); &#125; else &#123; a[tr + s - 1][tc + s - 1] = t; ChessBoard(tr, tc, tr + s - 1, tc + s - 1, s); &#125; if (dc &gt;= tc + s &amp;&amp; dr &lt; tr + s) &#123;//特殊方格在右上角 ChessBoard(tr, tc + s, dr, dc, s); &#125; else &#123; a[tr + s - 1][tc + s] = t; ChessBoard(tr, tc + s, tr + s - 1, tc + s, s); &#125; if (dc &lt; tc + s &amp;&amp; dr &gt;= tr + s) &#123;//特殊方格在左下角 ChessBoard(tr + s, tc, dr, dc, s); &#125; else &#123; a[tr + s][tc + s - 1] = t; ChessBoard(tr + s, tc, tr + s, tc + s - 1, s); &#125; if (dc &gt;= tc + s &amp;&amp; dr &gt;= tr + s) &#123;//特殊方格在右下角 ChessBoard(tr + s, tc + s, dr, dc, s); &#125; else &#123; a[tr + s][tc + s] = t; ChessBoard(tr + s, tc + s, tr + s, tc + s, s); &#125; &#125; public void Println(int a[][])&#123; for (int i=0;i&lt;a.length;i++)&#123; for (int j=0;j&lt;a[i].length;j++)&#123; System.out.printf(&quot;%d\\t&quot;,a[i][j]); &#125; System.out.println(&quot;&quot;); &#125; &#125; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n,i,j; System.out.println(&quot;请输入方格为多大，和特殊方格的坐标，例如16 2 3&quot;); n = in.nextInt(); i = in.nextInt(); j = in.nextInt(); Main yyp = new Main(); yyp.a = new int[n][n]; yyp.ChessBoard(0,0,i-1,j-1,n); yyp.Println(yyp.a); &#125;&#125; 结果","categories":[],"tags":[]},{"title":"数字三角","slug":"数字三角","date":"2021-03-12T01:36:24.000Z","updated":"2021-05-24T14:54:25.173Z","comments":true,"path":"2021/03/12/数字三角/","link":"","permalink":"http://example.com/2021/03/12/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92/","excerpt":"数字三角形","text":"数字三角形 问题描述从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或者右边的那个数。此外，向左下走的次数与向右下走的次数相差不能超过 1。 输入格式：输入的第一行包含一个整数 N，表示三角形的行数。 下面的 N 行给出数字三角形。 数字三角形上的数都是 0 至 100 之间的整数。 输出格式：输出一个整数，表示答案。 思路首先我们要缺、定这是一道动态规划题，其次我们要注意到的是题目中的 ==此外，向左下走的次数与向右下走的次数相差不能超过 1。==如果没有这一句话，我想大多数人都是可以写出来的，当然我先给大家讲解一下没有这句话应该怎么做，有这句话应该怎么做。==假如没有向左向右走的次数和相差不能超过1这个限定：==我们先将数据储存在一个二维矩阵A中，像这样。我们直接从数据的底层往上加，每次都取最大的往上加即可，递推公式为A[ i ][ j ] += max { A[ i+1 ][ j ] ,A[ i+1 ][ j+1 ]},最终我们输出A[0][0]即可。==有向左向右的限制怎么办呢？==来嘛~我们下往上行不通，那我们可以从上往下走，同样的我们要构造一个二维矩阵S，像这样。我们直接从上往下走，将我们数据中的每一个数都计算到内，每一个数的计算方式都是其左右的两个值中的较大者加上现在格子内的值。如下图于是我们最终得到了24 30 27 26 24，那有的小伙伴就要问了为什么是中间的数呢，其实原因很简单，就是因为向左向右的和不能超过1，加入一共有四次选择的机会，那必然是两次向左两次向右，当然如果是奇数次选择的机会，同理也是中间的两个值中的一个。因此我们直接输出中间的一个，或者中间两个的最大值。 实现1234567891011121314151617181920212223242526import java.util.Scanner;/*数字三角形 */public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int S[][] = new int[n+1][n+1]; for (int i=1;i&lt;=n;i++)&#123; for (int j=1;j&lt;i+1;j++)&#123; S[i][j] = in.nextInt(); &#125; &#125; for (int i=1;i&lt;=n;i++)&#123; for (int j=1;j&lt;i+1;j++)&#123; if (S[i-1][j-1]&gt;S[i-1][j]) S[i][j] += S[i-1][j-1]; else S[i][j] += S[i-1][j]; &#125; &#125; if (n%2==1) System.out.println(S[n][(n+1)/2]); else System.out.println(Math.max(S[n][n/2],S[n][n/2+1])); &#125;&#125; 测试 ==对您有帮助的话记得一键三连==","categories":[],"tags":[]},{"title":"Mybatis的执行流程和注解","slug":"Mybatis的执行流程和注解","date":"2021-03-05T13:10:12.000Z","updated":"2021-05-24T14:53:33.161Z","comments":true,"path":"2021/03/05/Mybatis的执行流程和注解/","link":"","permalink":"http://example.com/2021/03/05/Mybatis%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%92%8C%E6%B3%A8%E8%A7%A3/","excerpt":"Mybatis的执行流程和注解开发","text":"Mybatis的执行流程和注解开发 在没有使用注解的时候我们是需要实现我们dao层的接口，，当我们学完Mybatis之后，我们就不用去实现dao层的接口了，但是随之而来的是一个Mapper.xml文件，但是我们学完注解之后，我们连Mapper.xml文件也是可以不要的，于是我们的代码就变成了一个非常简洁的一个接口。那么我们要怎么才能去实现这个呢？首先我们要整理一下Mybatis的执行流程的思路： Mybatis的执行流程Resource获取加载全局配置文件—–&gt;实例化SqlSessionFactorBuilder构造器——-&gt;解析配置文件流XML ConfigBuilder——–&gt;Configuration所有配置信息——–&gt;SqlSessionFactory实例化——–&gt;transaction事务管理——–&gt;创建executor执行器—–&gt;创建sqlSession——-&gt;实现CRUD（增删改查）（返回transaction事务管理或者进行下一步）——&gt;查看是否执行成功——-&gt;（成功的话）提交事务 (失败的话)返回transaction事务管理—–&gt;关闭 注解开发首先我们还是准备开发所需要的环境：1、 maven依赖2、mybatis的核心配置文件3、一个实体类4、一个工具类5、编写dao接口（注解开发同时实现CRUD）6、测试第一步：maven依赖 123456789101112131415161718&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 第二步：mybatis的核心配置文件这里我就不过多的去解释核心配置文件的内容了，不了解的话，可以去我之前的文章看一下，这里就直接展示了。 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;properties resource=&quot;db.properties&quot; /&gt; &lt;typeAliases&gt; &lt;typeAlias type=&quot;com.yyp.pojo.User&quot; alias=&quot;yyp&quot;/&gt; &lt;package name=&quot;com.yyp.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper class=&quot;com.yyp.dao.UserMapper&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 第三步：一个实体类我们这里才用的还是之前文章所用的数据库，因此实体类没有变化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.yyp.pojo;public class User &#123; private int id; private String name; private String pwd; public User() &#123; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, pwd=&#x27;&quot; + pwd + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public User(int id, String name, String pwd) &#123; this.id = id; this.name = name; this.pwd = pwd; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125;&#125; 第四步：一个工具类这里和我之前文章中的代码有一个小小的变化，就是在通过SqlSessionFactor获得SqlSession的时候，在里面传一个参数，这就是自动提交事务的开关。打开之后，我们的事务就会自动提交。 123456789101112131415161718192021222324252627282930package com.yyp.utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.InputStream;public class MybatisUtils &#123; private static SqlSessionFactory sqlSessionFactory; static &#123; try &#123; //使用Mybatis String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(true); &#125;&#125; 第五步：编写dao层的接口 12345678910111213141516171819202122232425262728package com.yyp.dao;import com.yyp.pojo.User;import org.apache.ibatis.annotations.*;import java.util.List;import java.util.Map;public interface UserMapper &#123; //查询全部用户 @Select(&quot;select * from user&quot;) List&lt;User&gt; getUserList(); //有多个参数时，要用注解标注 @Select(&quot;select * from user where id = #&#123;id&#125;&quot;) User getUserByid(@Param(&quot;id&quot;) int id); @Insert(&quot;insert into user(id,name,pwd) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)&quot;) int addUser(User user); @Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id=#&#123;id&#125;&quot;) int updateUser(User user); @Delete(&quot;delete from user where id = #&#123;id&#125;&quot;) int deleteUser(@Param(&quot;id&quot;) int id);&#125; 其中我要说的就是当一个方法拥有多个参数的时候，我们就必须用@Paran（“id”）来注解我们的参数。当然如果一个参数的话，要不要都是可以的。第六步，测试这里测试，和之前的测试没有本支区别，就不再演示了。","categories":[],"tags":[]},{"title":"Mybatis的核心配置文件","slug":"Mybatis的核心配置文件","date":"2021-02-24T14:00:06.000Z","updated":"2021-05-24T14:53:19.635Z","comments":true,"path":"2021/02/24/Mybatis的核心配置文件/","link":"","permalink":"http://example.com/2021/02/24/Mybatis%E7%9A%84%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","excerpt":"Mybatis的核心配置文件","text":"Mybatis的核心配置文件 环境配置（environments）MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者想在具有相同 Schema 的多个生产数据库中使用相同的 SQL 映射。还有许多类似的使用场景。==简单的来说==就是：Mybatis可以根据不同的需求使用不同的环境，比如我们在开发的过程中是对用户的信息进行操作的，但是我们则是的时候并不是根据用户信息进行操作的，但是我们从新写一个环境是比较麻烦的，但是现在有一个机制可以帮助我们快速的切换环境，这就是环境配置。然后我们需要了解的就是每一套环境中都有哪些信息：1、事务管理器（transactionManager）在mybatis中有两种类型的事务管理器：JDBC和MANAGED==JDBC== 这个配置直接使用了 JDBC 的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域。==MANAGED== 这个配置几乎没做什么。我们一般使用JDBC进行事务提交。2、数据源（dataSource）mybatis有三种内建的数据源类型UNPOOLED、POOLED、JNDI==UNPOOLED（没有连接池）==这个数据源的实现会每次请求时打开和关闭连接。比较麻烦，一般不使用。==POOLED（连接池）== 这种处理方式很流行，在每一次请求并不会关闭连接，在运行效率上有很大的提升。这种处理方式使我们一般使用的，能使并发 Web 应用快速响应请求。==JNDI== 这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。 properties这就是我们之前使用的一些配置文件，我们需要在mybatis中通过properties标签来引用配置文件 1234&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&gt;&lt;/properties&gt; 当然我们完全可以将properties标签对中的property的键值对全部写在xx.properties文件中于是乎我们的代码可以简便为： 1&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;/&gt; typeAliases（类型别名）在上一篇文章中我们返回的一些类型都是通过全路径写的，这样的话就显得整个代码很冗余。那么我们该怎么做呢？在核心配置文件中配置typeAliases标签。 123&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.yyp.pojo.User&quot; alias=&quot;User&quot;/&gt;&lt;/typeAliases&gt; 这样的话，我们在Mapper.xml文件中就可以显示未这样： 123&lt;select id=&quot;getUserList&quot; resultType=&quot;User&quot;&gt; select * from mybatis.user&lt;/select&gt; 与之相近的还有一种是 123&lt;typeAliases&gt; &lt;package name=&quot;com.yyp.pojo&quot;/&gt;&lt;/typeAliases&gt; 这样的话，我们在Mapper.xml文件中就可以显示未这样： 123&lt;select id=&quot;getUserList&quot; resultType=&quot;user&quot;&gt; select * from mybatis.user&lt;/select&gt; 那么两种代码有什么区别呢，在我看来两种方式各自有各自的优势第一种，它给类起的别名可以自己随意设置第二种，他可以同时给一个包里的类全部设置别名，但是别名默认为类名的首字母小写，即我的类是User，则别名为user在使用第二种的方式之后，我们还能再实体类上使用注解，从而给实体类一个别名， 1234@Alias(&quot;abc&quot;)public class User &#123;&#125; 以上三种别名的方式是不存在优先级的，也就是说，三种方法设置的三个别名都是可以使用的。 settings（设置）这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 下表描述了设置中各项设置的含义、默认值等。|设置名|描述|有效值|默认值 ||–|–|–|–||cacheEnabled | 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。 | true或false | true||lazyLoadingEnabled|延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。|true或false | false|一个完整的settings元素的示例如下： 1234567891011121314151617&lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt; &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt; &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt; &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt; &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt; &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt; &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt; &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;&lt;/settings&gt; 其他配置typeHandlers（类型处理器）objectFactory（对象工厂）plugins插件 映射器（mappers）注册绑定我们的Mapper文件第一种方式：==推荐== 123&lt;mappers&gt; &lt;mapper resource=&quot;com/yyp/dao/UserMapper.xml&quot;/&gt;&lt;/mappers&gt; 第二种方式：使用class文件绑定注册，但是要保证Mapper.xml文件和接口必须同名；其次Mapper.xml文件必须和接口在同一个目录下。 123&lt;mappers&gt; &lt;mapper class=&quot;com.yyp.dao.UserMapper&quot;/&gt;&lt;/mappers&gt; 第三种方式：使用扫描宝进行注册绑定，但是要和方式二的注意点一样。 123&lt;mappers&gt; &lt;package name=&quot;com.yyp.dao&quot;/&gt;&lt;/mappers&gt;","categories":[],"tags":[]},{"title":"Mybatis入门","slug":"Mybatis入门","date":"2021-02-18T02:06:45.000Z","updated":"2021-05-24T14:51:19.053Z","comments":true,"path":"2021/02/18/Mybatis入门/","link":"","permalink":"http://example.com/2021/02/18/Mybatis%E5%85%A5%E9%97%A8/","excerpt":"Mybatis的应用","text":"Mybatis的应用 Mybatis的准备工作mybatis的中文文档：https://mybatis.org/mybatis-3/zh/index.html 准备工作具体有哪些我们用Idea的Maven项目来演示 。思路：搭建环境—–&gt;导入Mybatis依赖—–&gt;编写代码——-&gt;测试 Mybatis的实现1、搭建环境==搭建数据库任意数据库都可以==，如：==新建项目，导入Mybatis的maven的依赖== 123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; 以上就是我们项目的准备工作。 2、开始模块编写代码（参考Mybatis中文文档来学习）==代码的整体结构====编写Mybatis的核心配置文件-== 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;exin741963&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/yyp/dao/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 此代码是从Mybatis官方中文文档中拷贝过来的，其中我们需要将driver、url、username、password，四个属性的值根据自己的数据库进行配置。==最重要的是mappers这个标签== 它主要的作用就是将后面我们写的xml文件在这里注册一下。之后的每一个Mapper.xml文件都需要在Mybatis核心配置文件中注册！！！！！==IDEA连接数据库的方法==首先找到database，点击左上角的加号，找到MySQL连接上数据库之后就可以在IDEA上直接对数据库进行可视化==编写Mybatis工具类== 1234567891011121314151617181920public class MybatisUtils &#123; private static SqlSessionFactory sqlSessionFactory; static &#123; try &#123; //使用Mybatis String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(); &#125;&#125; 我们通过mybatis–config.xml文件创建一个SqlSessionFactor（我们可以理解为一个工厂），通过这个SqlSessionFactor工厂我们可以得到一个sqlsession，而通过sqlsession中的getMapper方法可以加载Dao中的接口，从而可以使用Dao中的方法。 3、编写代码==实体类==实体类主要是根据自己的数据库来编写的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class User &#123; private int id; private String name; private String pwd; public User() &#123; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, pwd=&#x27;&quot; + pwd + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public User(int id, String name, String pwd) &#123; this.id = id; this.name = name; this.pwd = pwd; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125;&#125; ==Dao接口==我们要实现面向接口的变成，因此我们首先要写一个接口我们的接口中包括了对数据库的增删改查的四种基本操作。 12345678910111213141516public interface UserMapper &#123; //查询全部用户 List&lt;User&gt; getUserList(); //根据ID查询用户 User getUserById(int id); //insert一个用户 int addUser(User user); //修改用户 int updateUser(User user); //删除一个用户 int deleteUser(int id);&#125; ==接口实现==在没有学习Mybatis的时候，我们是需要编写一个接口的实现类的，但是在mybatis中我们用一个xml文件来代替之前的接口实现。 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--绑定一个对应的Dao/Mapper接口--&gt;&lt;mapper namespace=&quot;com.yyp.dao.UserMapper&quot;&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;com.yyp.pojo.User&quot;&gt; select * from mybatis.user &lt;/select&gt; &lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.yyp.pojo.User&quot;&gt; select * from mybatis.user where id = #&#123;id&#125; &lt;/select&gt; &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.yyp.pojo.User&quot;&gt; insert into mybatis.user (id,name,pwd) value (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;) &lt;/insert&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.yyp.pojo.User&quot;&gt; update mybatis.user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from mybatis.user where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 测试测试的基本操作都是三行代码，不同的就是调用的方法不同，在这里我们就以查询全部用户为例。 1234567891011public void test()&#123; //第一步获得SQLSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); //执行SQL UserMapper userDao = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = userDao.getUserList(); for (User user : userList)&#123; System.out.println(user); &#125; sqlSession.close(); &#125; 会遇到的一些问题1、org.apache.ibatis.binding.BindingException: Type interface com.yyp.dao.UserMapper is not known to the MapperRegistry.这是因为没有注册你的Mapper导致的，需要你在mybatis-config.xml文件中添加Mapper的注册内容 2、java.io.IOException: Could not find resource com/yyp/dao/UserMapper.xml这是由于Maven的约定大于配置，导致我们遇到写的配置文件无法被导出或者生效的问题，解决方案：在maven中加入build。 1234567891011121314151617181920&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 3、（小编认为最坑的一个错误）org.xml.sax.SAXParseException; lineNumber: 7; columnNumber: 5; 1 字节的 UTF-8 序列的字节 1 无效。这个小编在遇到的时候，百度了很久，有人说是注释的问题，我刚开始不信，最后真的就是因为中文注释，文件头的encoding=”UTF-8”会编译注释中的中文，导致无法识别的错误，因此有两种修改的方法，第一种直接将注释删掉，第二种将UTF-8改为UTF8就可以了。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"SpringBoot自动装配原理","slug":"SpringBoot自动装配原理","date":"2021-02-08T12:15:40.000Z","updated":"2021-05-24T14:50:40.871Z","comments":true,"path":"2021/02/08/SpringBoot自动装配原理/","link":"","permalink":"http://example.com/2021/02/08/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/","excerpt":"原理初次探","text":"原理初次探 自动配置pom.xmlspring-boot-dependencies：核心依赖在父工程中！我们在写或者引入一些SpringBoot依赖的时候，不需要指定版本，就是因为有这些版本的仓库 启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; 启动器：简单的来说就是SpringBoot的启动场景；比如spring-boot-starter-web，他就会帮我们自动导入web环境所有的依赖！springboot会将所有的工程场景，都封装成一个个的启动器，我们需要使用寿命功能，就只需要找到对应的启动器就可以了。下面是spring官网的启动器的网址：https://docs.spring.io/spring-boot/docs/2.4.4/reference/html/using-spring-boot.html#using-boot-starter 主程序123456789@SpringBootApplicationpublic class DemoApplication &#123; //将SpringBoot应用启动 public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 注解123456789101112131415161718192021222324252627282930@SpringBootConfiguration //spting的配置 @Configuration //spring配置类 @Component //说明也是spring的一个组件@EnableAutoConfiguration //自动导入包 @AutoConfigurationPackage //自动配置包 @AutoConfigurationPackage // 自动配置包注册 @Import(&#123;AutoConfigurationImportSelector.class&#125;) // 自动导入选择器 AutoConfigurationImportSelector：自动导入选择器 getAutoConfigurationEntry()获得自动配置的实体 getCandidateConfigurations()获取候选的配置 protected Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123; return EnableAutoConfiguration.class; &#125;标注了EnableAutoConfiguration注解的类 public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) &#123; ClassLoader classLoaderToUse = classLoader; if (classLoader == null) &#123; classLoaderToUse = SpringFactoriesLoader.class.getClassLoader(); &#125; String factoryTypeName = factoryType.getName(); return (List)loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList()); &#125;获取所有的加载配置 loadSpringFactories classLoader.getResources(&quot;META-INF/spring.factories&quot;);获取资源 spring-boot-autoconfigure-2.2.0.RELEASE.jar META-INF spring.factories：所有的自动配置都在这里 这么多自动配置类为什么有的没有生效，需要导入对应的start才能生效 核心注解：@ConditionalOnXXX如果里面的条件都满足，才会生效 总结springboot所有的自动配置都是在启动的时候启动并加载：所有的自动配置都在spring.factories，所有的自动配置类都在文件中，但是不一定生效，要满足条件才能加载，只要导入了对应的start，就有对应的启动器了，有了启动器，我们的自动装配就会生效，然后就自动配置完成了","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"SpringMVC的第一个程序","slug":"SpringMVC的第一个程序","date":"2021-02-02T08:30:36.000Z","updated":"2021-05-24T14:50:13.193Z","comments":true,"path":"2021/02/02/SpringMVC的第一个程序/","link":"","permalink":"http://example.com/2021/02/02/SpringMVC%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/","excerpt":"@SpringMVC的第一个程序","text":"@SpringMVC的第一个程序 1、我们按照之前的套路来完成SpringMVC的学习，首先环境的思路就是越简单越好。2、我们首先创建一个空白的项目来作为主工程3、我们在主工程里面创建空白模板来完成我们的第一个项目。（添加Farmework support）4、导入我们所需要的Maven依赖！ 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 5、导入依赖之后我们就要完成我们程序的入口，也就是DispatcherServlet。（即我们的web.xml） 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 其主要就是一个Servlet的注册，相比之前的Servlet而言就是在servlet标签下多了两个标签，init-param标签是关联一个springmvc的配置文件。而load-on-startup则是设置启动级别为1（即程序开始就加载）。6、上一步我们关联了一个springmvc的一个配置文件，因此这一步该干什么就清楚明了了，于是我们就要编写springmvc-servlet.xml文件 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; 我们按照官方的来（看不懂也没事，先照着做，之后用注释编写程序的话这些是没有必要的）添加处理映射器 123&lt;beanclass=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt; 添加处理适配器 123&lt;beanclass=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt; 添加视图解析器 123456789&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;&lt;beanclass=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;id=&quot;InternalResourceViewResolver&quot;&gt;&lt;!--前缀--&gt;&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;&lt;!--后缀--&gt;&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt; 这里钱前缀和后缀的值是为了拼接地址的，这么我们会返回一个hello，即我们要求请求一个/WEB-INF/jsp/hello.jsp页面7、编写我们的业务操作Controller 123456789public class Controller implements org.springframework.web.servlet.mvc.Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;,&quot;Welcome to Spring&quot;); mv.setViewName(&quot;hello&quot;); return mv; &#125;&#125; 8、将这个类交给springIOC容器、注册bean 1&lt;bean id=&quot;/hello&quot; class=&quot;com.yyp.controller.Controller&quot;/&gt; 9、添加Tomcat10、测试（这里就不掩饰了） 可能会遇到的问题404output的WEB-INF下面没有lib包解决：在项目结构中进行一下操作。 500Caused by: org.xml.sax.SAXParseException; lineNumber: 1; columnNumber: 1; 前言中不允许有内容 我是因为在写web.xml的时候，没有关联springmvc的配置文件的时候没有写文件，因此文件名字我给忘了写了，所以导致我的代码出现500的错误异常。 解决方案：在servlet里面补充完成关联配置文件的名称。","categories":[],"tags":[]},{"title":"干净的ssm框架","slug":"干净的ssm框架","date":"2021-01-26T08:01:31.000Z","updated":"2021-05-24T14:29:11.039Z","comments":true,"path":"2021/01/26/干净的ssm框架/","link":"","permalink":"http://example.com/2021/01/26/%E5%B9%B2%E5%87%80%E7%9A%84ssm%E6%A1%86%E6%9E%B6/","excerpt":"如何搭建一个SSM框架的项目==拒绝白嫖，白嫖有罪，点个赞再走呗==","text":"如何搭建一个SSM框架的项目==拒绝白嫖，白嫖有罪，点个赞再走呗== 首先要有哪些配置（准备工作1）环境要求IDE：IDEA数据库：MySQLTomCat 8Maven 3.6自身要求：需要熟练掌握数据库，spring，JavaWeb及MyBatis知识，简单的前段知识 数据库要求 开始搭建项目（准备工作2）1、新建一maven空项目！添加web的支持2、导入相关的pom依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; == 每次导入依赖就必须添加对应的lib包，否则就会出现500错误或者tomcat直接跑不起来== 3、Maven资源过滤设置（未解决资源大于配置的一些问题，如资源加载不了等问题。）1234567891011121314151617181920&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 搭建合适的包结构 mybatis-config.xml文件两件事：第一件事：起别名（可以不起，但是后面的开发都需要写类的全名）第二件事：注册Mapper（按照我的模板写，将Mapper放在dao层下面，直接扫描包就行了） 1234567&lt;typeAliases&gt; &lt;package name=&quot;com.yyp.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;package name=&quot;com.yyp.dao&quot;/&gt; &lt;/mappers&gt; 编写实体类我们偷懒使用lombok插件，（导入依赖即可使用，我们上面已经导入过了） 123456789@Data//get，set方法@AllArgsConstructor//有参构造，但是会将无参构造给干掉@NoArgsConstructor//上面的注解会将无参构造给干掉，下面可以加上无参构造public class Books &#123; private int bookID; private String bookName; private int bookCounts; private String detail;&#125; 完成dao层首先我们需要一个接口和一个配置文件对吧，来嘛==接口== 123456789101112131415161718192021public interface BookMapper &#123; //增加一本书 int addBook(Books books); //删除一本书 int deleteBookByID(@Param(&quot;bookid&quot;) int id); //更新一本书 int updateBook(Books books); //查询一本书 Books queryBookByID(@Param(&quot;bookid&quot;) int id); //查询全部书 List&lt;Books&gt; queryAllBook(); //查询书籍 Books queryBookByName(@Param(&quot;bookName&quot;) String bookName);&#125; ==配置文件== 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.yyp.dao.BookMapper&quot;&gt; &lt;insert id=&quot;addBook&quot; parameterType=&quot;Books&quot;&gt; insert into ssmbuild.books(bookName,bookCounts,detail) value (#&#123;bookName&#125;,#&#123;bookCounts&#125;,#&#123;detail&#125;) &lt;/insert&gt; &lt;delete id=&quot;deleteBookByID&quot; parameterType=&quot;int&quot;&gt; delete from ssmbuild.books where bookID = #&#123;bookid&#125; &lt;/delete&gt; &lt;update id=&quot;updateBook&quot; parameterType=&quot;Books&quot;&gt; update ssmbuild.books set bookName=#&#123;bookName&#125;,bookCounts=#&#123;bookCounts&#125;,detail=#&#123;detail&#125; where bookID=#&#123;bookID&#125; &lt;/update&gt; &lt;select id=&quot;queryBookByID&quot; resultType=&quot;Books&quot;&gt; select * from ssmbuild.books where bookID=#&#123;bookid&#125; &lt;/select&gt; &lt;select id=&quot;queryAllBook&quot; resultType=&quot;Books&quot;&gt; select * from ssmbuild.books &lt;/select&gt; &lt;select id=&quot;queryBookByName&quot; resultType=&quot;Books&quot;&gt; select * from ssmbuild.books where BookName=#&#123;bookName&#125; &lt;/select&gt; &lt;/mapper&gt; 这就是我们在Mybatis中学习的基本的Mapper的使用，不懂得可以去看Mybatis Service层service层就是调用dao层实现一些业务的，由于我们是一个干净的模板，所有没有特别复杂的业务，直接调用dao层就可以出来结果，因此我们的servic层和dao层有点相似，但是不能省略。service是一个接口一个实现类，来嘛==接口== 1234567891011121314151617181920public interface BookService &#123; //增加一本书 int addBook(Books books); //删除一本书 int deleteBookByID( int id); //更新一本书 int updateBook(Books books); //查询一本书 Books queryBookByID( int id); //查询全部书 List&lt;Books&gt; queryAllBook(); //查询书籍 Books queryBookByName(String bookName);&#125; ==实现类== 12345678910111213141516171819202122232425262728293031323334public class BookserviceImpl implements BookService&#123; //service掉dao层:组合Dao @Autowired private BookMapper bookMapper; public void setBookMapper(BookMapper bookMapper) &#123; this.bookMapper = bookMapper; &#125; public int addBook(Books books) &#123; return bookMapper.addBook(books); &#125; public int deleteBookByID(int id) &#123; return bookMapper.deleteBookByID(id); &#125; public int updateBook(Books books) &#123; return bookMapper.updateBook(books); &#125; public Books queryBookByID(int id) &#123; return bookMapper.queryBookByID(id); &#125; public List&lt;Books&gt; queryAllBook() &#123; return bookMapper.queryAllBook(); &#125; public Books queryBookByName(String bookName) &#123; return bookMapper.queryBookByName(bookName); &#125;&#125; spring-dao.xml数据库配置文件1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=falsejdbc.username=rootjdbc.password=exin741963 这里要写自己的数据库配置，而且前面的jdbc.不能省略，否侧会出现数据库错误，可以先省略试一次错误，这样以后就不会出错了。 四步曲：1、关联数据库文件 1&lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt; 2、连接池 123456789101112131415&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;!--c3p0连接池的私有属性--&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt; &lt;!--关闭连接后不自动commit--&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt; &lt;!--获取连接超时时间--&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt; &lt;!--当获取连接失败重试次数--&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt; &lt;/bean&gt; 3、SqlSessionFactor 12345&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--绑定mybatis的配置文件--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;/bean&gt; 4、配置dao接口扫描包，动态的实现了Dao接口可以注入到spring容器 123456&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!--注入SqlSessionFactory--&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!--要扫描的dao包--&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.yyp.dao&quot;/&gt; &lt;/bean&gt; spring-service.xml三部曲（主要就是spring5的bean的东西）1、扫描service下的包 1&lt;context:component-scan base-package=&quot;com.yyp.service&quot;/&gt; 2、将我们的所有业务类，注入到Spring，可以通过配置或注解实现 123&lt;bean id=&quot;BookserviceImpl&quot; class=&quot;com.yyp.service.BookserviceImpl&quot;&gt; &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;/&gt;&lt;/bean&gt; 3、声明事务配置 1234&lt;bean id=&quot;transactionManage&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; 这一步可能会出错，原因是你没有将这几个容器（xml配置文件）放在一些。最简单的解决的方法就是在applicationContext导入这些配置文件。在我们编写mvc的配置文件之后，我就不在提示了。 spring mvc的配置web.xml主要就是DispathchServlet 1234567891011121314&lt;!--DispatchServlet--&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 乱码处理 123456789101112&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; session这是有效时长 123&lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt; spring-mvc.xml1、注解驱动 1&lt;mvc:annotation-driven/&gt; 2、静态资源过滤 1&lt;mvc:default-servlet-handler/&gt; 3、扫描包：controller 1&lt;contest:component-scan base-package=&quot;com.yyp.controller&quot;/&gt; 4、视图解析器 1234&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt; 以上就是全部的准备工作，下面是业务，不在讲解，代码自己参考。controller1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Controller@RequestMapping(&quot;/book&quot;)public class BookController &#123; @Autowired @Qualifier(&quot;BookserviceImpl&quot;) private BookService bookService; //查询全部的书籍，并且返回到一个书籍展示页面 @RequestMapping(&quot;/allBook&quot;) public String list(Model model)&#123; List&lt;Books&gt; list = bookService.queryAllBook(); model.addAttribute(&quot;list&quot;,list); return &quot;allBook&quot;; &#125; //跳转到增加书籍页面 @RequestMapping(&quot;toAddBook&quot;) public String toAddPager()&#123; return &quot;addBook&quot;; &#125; //添加书籍的请求 @RequestMapping(&quot;addBook&quot;) public String addBook(Books books)&#123; bookService.addBook(books); return &quot;redirect:/book/allBook&quot;; &#125; //跳转到书籍页面 @RequestMapping(&quot;toUpdatePager&quot;) public String toUpdatePager(int id,Model model)&#123; Books books = bookService.queryBookByID(id); model.addAttribute(&quot;QBook&quot;,books); return &quot;updateBook&quot;; &#125; //修改书籍 @RequestMapping(&quot;/updateBook&quot;) public String updateBook(Books books)&#123; bookService.updateBook(books); return &quot;redirect:/book/allBook&quot;; &#125; //删除书籍 @RequestMapping(&quot;deleteBook&quot;) public String deleteBook(int id)&#123; bookService.deleteBookByID(id); return &quot;redirect:/book/allBook&quot;; &#125; //查询书籍 @RequestMapping(&quot;queryBook&quot;) public String queryBook(String queryBookName,Model model)&#123; Books books = bookService.queryBookByName(queryBookName); List&lt;Books&gt; list = new ArrayList&lt;Books&gt;(); list.add(books); if(books==null)&#123; list = bookService.queryAllBook(); model.addAttribute(&quot;error&quot;,&quot;未查到&quot;); &#125; model.addAttribute(&quot;list&quot;,list); return &quot;allBook&quot;; &#125;&#125; jsp页面index.jsp123456789101112131415161718192021222324252627282930&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;首页&lt;&#x2F;title&gt; &lt;style&gt; a&#123; text-decoration: none; color: #00ffe1; font-size: 18px; &#125; h3&#123; width: 180px; height: 38px; margin: 100px auto; text-align: center; line-height: 38px; background: deepskyblue; border-radius: 5px ; &#125; &lt;&#x2F;style&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;h3&gt;&lt;a href&#x3D;&quot;&#x2F;book&#x2F;allBook&quot;&gt;跳转书籍页面&lt;&#x2F;a&gt; &lt;&#x2F;h3&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; addBook.jsp1234567891011121314151617181920212223242526272829303132333435363738394041&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;添加书籍页面&lt;&#x2F;title&gt; &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;twitter-bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div class&#x3D;&quot;container&quot;&gt; &lt;div class&#x3D;&quot;row clearfix&quot;&gt; &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt; &lt;div class&#x3D;&quot;page-header&quot;&gt; &lt;small&gt;新增书记&lt;&#x2F;small&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;form action&#x3D;&quot;&#x2F;book&#x2F;addBook&quot; method&#x3D;&quot;post&quot;&gt; &lt;div class&#x3D;&quot;form-group&quot;&gt; &lt;label for&#x3D;&quot;bkname&quot;&gt;书籍名称&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; id&#x3D;&quot;bkname&quot; name&#x3D;&quot;bookName&quot; required&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;form-group&quot;&gt; &lt;label for&#x3D;&quot;bkcounts&quot;&gt;书籍数量&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; id&#x3D;&quot;bkcounts&quot; name&#x3D;&quot;bookCounts&quot; required&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;form-group&quot;&gt; &lt;label for&#x3D;&quot;detali&quot;&gt;书籍详情&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; id&#x3D;&quot;detali&quot; name&#x3D;&quot;detail&quot; required&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;form-group&quot;&gt; &lt;input type&#x3D;&quot;submit&quot; class&#x3D;&quot;form-control&quot; value&#x3D;&quot;添加&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;form&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; allBook.jsp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;书籍展示页面&lt;&#x2F;title&gt; &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;twitter-bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div class&#x3D;&quot;container&quot;&gt; &lt;div class&#x3D;&quot;row clearfix&quot;&gt; &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt; &lt;div class&#x3D;&quot;page-header&quot;&gt; &lt;small&gt;书籍列表——————显示所有书籍&lt;&#x2F;small&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;row&quot;&gt; &lt;div class&#x3D;&quot;col-md-4 column&quot;&gt; &lt;a class&#x3D;&quot;btn btn-primary&quot; href&#x3D;&quot;&#x2F;book&#x2F;toAddBook&quot;&gt;新增书籍&lt;&#x2F;a&gt; &lt;a class&#x3D;&quot;btn btn-primary&quot; href&#x3D;&quot;&#x2F;book&#x2F;allBook&quot;&gt;显示全部书籍&lt;&#x2F;a&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;col-md-4 column&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;form-inline&quot;&gt; &lt;form action&#x3D;&quot;&#x2F;book&#x2F;queryBook&quot; method&#x3D;&quot;post&quot; style&#x3D;&quot;float: right&quot;&gt; &lt;span style&#x3D;&quot;color: red&quot;&gt;$&#123;error&#125;&lt;&#x2F;span&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;queryBookName&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;请输入要查询的书籍名称&quot;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;查询&quot; class&#x3D;&quot;btn btn-primary&quot;&gt; &lt;&#x2F;form&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;row clearfix&quot;&gt; &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt; &lt;table class&#x3D;&quot;table table-hover table-striper&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;书籍编号&lt;&#x2F;th&gt; &lt;th&gt;书籍名称&lt;&#x2F;th&gt; &lt;th&gt;书籍数量&lt;&#x2F;th&gt; &lt;th&gt;书籍详情&lt;&#x2F;th&gt; &lt;th&gt;操作&lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;%--书籍从数据库中查询出来，从这个list中便利出来：foreach--%&gt; &lt;tbody&gt; &lt;c:forEach var&#x3D;&quot;book&quot; items&#x3D;&quot;$&#123;list&#125;&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.bookID&#125;&lt;&#x2F;td&gt; &lt;td&gt;$&#123;book.bookName&#125;&lt;&#x2F;td&gt; &lt;td&gt;$&#123;book.bookCounts&#125;&lt;&#x2F;td&gt; &lt;td&gt;$&#123;book.detail&#125;&lt;&#x2F;td&gt; &lt;td&gt; &lt;a href&#x3D;&quot;&#x2F;book&#x2F;toUpdatePager?id&#x3D;$&#123;book.bookID&#125;&quot;&gt;修改&lt;&#x2F;a&gt; &amp;nbsp; | &amp;nbsp; &lt;a href&#x3D;&quot;&#x2F;book&#x2F;deleteBook?id&#x3D;$&#123;book.bookID&#125;&quot;&gt;删除&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;c:forEach&gt; &lt;&#x2F;tbody&gt; &lt;&#x2F;table&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; updateBook.jsp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: 27211 Date: 2021&#x2F;3&#x2F;16 Time: 22:48 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;修改书籍页面&lt;&#x2F;title&gt; &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;twitter-bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div class&#x3D;&quot;container&quot;&gt; &lt;div class&#x3D;&quot;row clearfix&quot;&gt; &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt; &lt;div class&#x3D;&quot;page-header&quot;&gt; &lt;small&gt;修改书记&lt;&#x2F;small&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;form action&#x3D;&quot;&#x2F;book&#x2F;updateBook&quot; method&#x3D;&quot;post&quot;&gt; &lt;%--id没有传送，前段传递隐藏域--%&gt; &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;bookID&quot; value&#x3D;&quot;$&#123;QBook.bookID&#125;&quot;&gt; &lt;div class&#x3D;&quot;form-group&quot;&gt; &lt;label for&#x3D;&quot;bkname&quot;&gt;书籍名称&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; id&#x3D;&quot;bkname&quot; name&#x3D;&quot;bookName&quot; required value&#x3D;&quot;$&#123;QBook.bookName&#125;&quot;&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;form-group&quot;&gt; &lt;label for&#x3D;&quot;bkcounts&quot;&gt;书籍数量&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; id&#x3D;&quot;bkcounts&quot; name&#x3D;&quot;bookCounts&quot; required value&#x3D;&quot;$&#123;QBook.bookCounts&#125;&quot;&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;form-group&quot;&gt; &lt;label for&#x3D;&quot;detali&quot;&gt;书籍详情&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; id&#x3D;&quot;detali&quot; name&#x3D;&quot;detail&quot; required value&#x3D;&quot;$&#123;QBook.detail&#125;&quot;&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;form-group&quot;&gt; &lt;input type&#x3D;&quot;submit&quot; class&#x3D;&quot;form-control&quot; value&#x3D;&quot;修改&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;form&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"SpringSecurity理解","slug":"SpringSecurity理解","date":"2021-01-24T05:18:58.000Z","updated":"2021-05-24T05:39:09.145Z","comments":true,"path":"2021/01/24/SpringSecurity理解/","link":"","permalink":"http://example.com/2021/01/24/SpringSecurity%E7%90%86%E8%A7%A3/","excerpt":"@TOCSpringSecurity的重要核心功能是：==用户授权、用户认证==","text":"@TOCSpringSecurity的重要核心功能是：==用户授权、用户认证== 特点 和Spring无缝整合 全面的权限控制 专门为Web开发而设计 旧版本不能脱离Web 新版本对整个框架进行了分层抽取，分成了核心模块和Web模块。单独引入核心模块就可以脱离Web环境 重量级SpringSecurity的Hello项目创建一个项目第一步：创建一个SpringBoot项目。 第二步：引入需要的依赖。 1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 第三步：创建TestController 1234567891011121314151617package com.yyp.securitydemo1.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(&quot;/test&quot;)public class TestController &#123; @GetMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;hello security&quot;; &#125;&#125; 运行这个项目上面我们创建了一个非常简单的SpringBoot的项目，当我们运行的时候回发成上面呢？首先我们疑惑地是。这个页面哪里来的，为什么回来到这个页面，我们访问的controller有没有访问到呢？这个我在接下来会告诉大家，现在我们来登录一下，SpringSecurity默认的用户名是user密码会在后台告诉我们。登录之后，我们就访问到了我们的controller SpringSecurity的本质SpringSecurity的本质就是过滤器链FilterSecurityInterceptor：是一个方法的权限过滤器，基本位于过滤链的最底层ExceptionTranslationFilter：是一个异常过滤器，用来处理在认证授权过程中抛出的异常UsernamePasswordAuthenticationFilter：对/login的POST请求做拦截，校验表单中的用户名，密码 过滤器是如何加载的？1、使用SpringSecurity配置过滤器2、DelegatingFilterProxy类中的doFilter会首先运行3、在doFilter方法中delegateToUse = initDelegate(wac);调用initDelegate方法4、Filter delegate = (Filter)wac.getBean(targetBeanName, Filter.class);在当前作用域获取对象名字为springSecurityFilterChain的，返回一个过滤器对象。 SpringSecurity设置登录的用户名和密码1、用过配置文件直接在application.yaml中配置就可以 2、通过配置类1234567891011121314151617181920212223242526package com.yyp.securitydemo1.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); String password = passwordEncoder.encode(&quot;123&quot;); auth.inMemoryAuthentication().withUser(&quot;lucy&quot;).password(password).roles(&quot;admin&quot;); &#125; @Bean PasswordEncoder password()&#123; return new BCryptPasswordEncoder(); &#125;&#125; 3、自定义实现类设置==注意将配置类注释掉，删除配置文件中的配置==第一步：创建配置类，设置使用哪个userDetailsService实现类 12345678910111213141516171819202122232425262728package com.yyp.securitydemo1.config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;@Configurationpublic class SecurityConfigTest extends WebSecurityConfigurerAdapter &#123; @Autowired private UserDetailsService userDetailsService; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userDetailsService).passwordEncoder(password()); &#125; @Bean PasswordEncoder password()&#123; return new BCryptPasswordEncoder(); &#125;&#125; 第二步：编写实现类，返回User对象，User对象有用户名密码和操作权限 123456789@Service(&quot;userDetailsService&quot;)public class MyUserDetailsService implements UserDetailsService &#123; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; List&lt;GrantedAuthority&gt; auths = AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;role&quot;); return new User(&quot;mary&quot;,new BCryptPasswordEncoder().encode(&quot;123&quot;),auths); &#125;&#125; 我们通过数据库查到用户的用户名密码和权限，通过User来进行认证。 SpringSecurity-Web权限方案（真正的数据库实现）思路：整合一个框架MybatisPlus。 引入依赖123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.1.tmp&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 创建数据库和数据库表 创建实体类123456789101112131415package com.yyp.securitydemo1.entity;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Users &#123; private Integer id; private String username; private String password;&#125; 整合MybatisPlus，创建接口，继承MybatisPlus接口12public interface UsersMapper extends BaseMapper&lt;Users&gt; &#123;&#125; 在MyUserDetailsService调用mapper里面得方法查询数据库进行用户认证12345678910111213141516171819202122232425262728293031323334353637package com.yyp.securitydemo1.service;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.yyp.securitydemo1.entity.Users;import com.yyp.securitydemo1.mapper.UsersMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.AuthorityUtils;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.stereotype.Service;import java.util.List;@Service(&quot;userDetailsService&quot;)public class MyUserDetailsService implements UserDetailsService &#123; @Autowired private UsersMapper usersMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; QueryWrapper&lt;Users&gt; wrapper = new QueryWrapper(); wrapper.eq(&quot;username&quot;,username); Users user = usersMapper.selectOne(wrapper); if (user == null)&#123; throw new UsernameNotFoundException(&quot;用户名不存在!&quot;); &#125; List&lt;GrantedAuthority&gt; auths = AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;role&quot;); return new User(user.getUsername(),new BCryptPasswordEncoder().encode(user.getPassword()),auths); &#125;&#125; 添加mapper扫描","categories":[],"tags":[]},{"title":"如何搭建一个SSM框架的项目","slug":"如何搭建一个SSM框架的项目","date":"2021-01-20T05:32:41.000Z","updated":"2021-05-24T05:39:07.098Z","comments":true,"path":"2021/01/20/如何搭建一个SSM框架的项目/","link":"","permalink":"http://example.com/2021/01/20/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AASSM%E6%A1%86%E6%9E%B6%E7%9A%84%E9%A1%B9%E7%9B%AE/","excerpt":"@TOC==拒绝白嫖，白嫖有罪，点个赞再走呗==","text":"@TOC==拒绝白嫖，白嫖有罪，点个赞再走呗== 首先要有哪些配置（准备工作1）环境要求IDE：IDEA数据库：MySQLTomCat 8Maven 3.6自身要求：需要熟练掌握数据库，spring，JavaWeb及MyBatis知识，简单的前段知识 数据库要求 开始搭建项目（准备工作2）1、新建一maven空项目！添加web的支持2、导入相关的pom依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; == 每次导入依赖就必须添加对应的lib包，否则就会出现500错误或者tomcat直接跑不起来== 3、Maven资源过滤设置（未解决资源大于配置的一些问题，如资源加载不了等问题。）1234567891011121314151617181920&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 搭建合适的包结构 mybatis-config.xml文件两件事：第一件事：起别名（可以不起，但是后面的开发都需要写类的全名）第二件事：注册Mapper（按照我的模板写，将Mapper放在dao层下面，直接扫描包就行了） 1234567&lt;typeAliases&gt; &lt;package name=&quot;com.yyp.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;package name=&quot;com.yyp.dao&quot;/&gt; &lt;/mappers&gt; 编写实体类我们偷懒使用lombok插件，（导入依赖即可使用，我们上面已经导入过了） 123456789@Data//get，set方法@AllArgsConstructor//有参构造，但是会将无参构造给干掉@NoArgsConstructor//上面的注解会将无参构造给干掉，下面可以加上无参构造public class Books &#123; private int bookID; private String bookName; private int bookCounts; private String detail;&#125; 完成dao层首先我们需要一个接口和一个配置文件对吧，来嘛==接口== 123456789101112131415161718192021public interface BookMapper &#123; //增加一本书 int addBook(Books books); //删除一本书 int deleteBookByID(@Param(&quot;bookid&quot;) int id); //更新一本书 int updateBook(Books books); //查询一本书 Books queryBookByID(@Param(&quot;bookid&quot;) int id); //查询全部书 List&lt;Books&gt; queryAllBook(); //查询书籍 Books queryBookByName(@Param(&quot;bookName&quot;) String bookName);&#125; ==配置文件== 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.yyp.dao.BookMapper&quot;&gt; &lt;insert id=&quot;addBook&quot; parameterType=&quot;Books&quot;&gt; insert into ssmbuild.books(bookName,bookCounts,detail) value (#&#123;bookName&#125;,#&#123;bookCounts&#125;,#&#123;detail&#125;) &lt;/insert&gt; &lt;delete id=&quot;deleteBookByID&quot; parameterType=&quot;int&quot;&gt; delete from ssmbuild.books where bookID = #&#123;bookid&#125; &lt;/delete&gt; &lt;update id=&quot;updateBook&quot; parameterType=&quot;Books&quot;&gt; update ssmbuild.books set bookName=#&#123;bookName&#125;,bookCounts=#&#123;bookCounts&#125;,detail=#&#123;detail&#125; where bookID=#&#123;bookID&#125; &lt;/update&gt; &lt;select id=&quot;queryBookByID&quot; resultType=&quot;Books&quot;&gt; select * from ssmbuild.books where bookID=#&#123;bookid&#125; &lt;/select&gt; &lt;select id=&quot;queryAllBook&quot; resultType=&quot;Books&quot;&gt; select * from ssmbuild.books &lt;/select&gt; &lt;select id=&quot;queryBookByName&quot; resultType=&quot;Books&quot;&gt; select * from ssmbuild.books where BookName=#&#123;bookName&#125; &lt;/select&gt; &lt;/mapper&gt; 这就是我们在Mybatis中学习的基本的Mapper的使用，不懂得可以去看Mybatis Service层service层就是调用dao层实现一些业务的，由于我们是一个干净的模板，所有没有特别复杂的业务，直接调用dao层就可以出来结果，因此我们的servic层和dao层有点相似，但是不能省略。service是一个接口一个实现类，来嘛==接口== 1234567891011121314151617181920public interface BookService &#123; //增加一本书 int addBook(Books books); //删除一本书 int deleteBookByID( int id); //更新一本书 int updateBook(Books books); //查询一本书 Books queryBookByID( int id); //查询全部书 List&lt;Books&gt; queryAllBook(); //查询书籍 Books queryBookByName(String bookName);&#125; ==实现类== 12345678910111213141516171819202122232425262728293031323334public class BookserviceImpl implements BookService&#123; //service掉dao层:组合Dao @Autowired private BookMapper bookMapper; public void setBookMapper(BookMapper bookMapper) &#123; this.bookMapper = bookMapper; &#125; public int addBook(Books books) &#123; return bookMapper.addBook(books); &#125; public int deleteBookByID(int id) &#123; return bookMapper.deleteBookByID(id); &#125; public int updateBook(Books books) &#123; return bookMapper.updateBook(books); &#125; public Books queryBookByID(int id) &#123; return bookMapper.queryBookByID(id); &#125; public List&lt;Books&gt; queryAllBook() &#123; return bookMapper.queryAllBook(); &#125; public Books queryBookByName(String bookName) &#123; return bookMapper.queryBookByName(bookName); &#125;&#125; spring-dao.xml数据库配置文件1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=falsejdbc.username=rootjdbc.password=exin741963 这里要写自己的数据库配置，而且前面的jdbc.不能省略，否侧会出现数据库错误，可以先省略试一次错误，这样以后就不会出错了。 四步曲：1、关联数据库文件 1&lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt; 2、连接池 123456789101112131415&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;!--c3p0连接池的私有属性--&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt; &lt;!--关闭连接后不自动commit--&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt; &lt;!--获取连接超时时间--&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt; &lt;!--当获取连接失败重试次数--&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt; &lt;/bean&gt; 3、SqlSessionFactor 12345&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--绑定mybatis的配置文件--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;/bean&gt; 4、配置dao接口扫描包，动态的实现了Dao接口可以注入到spring容器 123456&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!--注入SqlSessionFactory--&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!--要扫描的dao包--&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.yyp.dao&quot;/&gt; &lt;/bean&gt; spring-service.xml三部曲（主要就是spring5的bean的东西）1、扫描service下的包 1&lt;context:component-scan base-package=&quot;com.yyp.service&quot;/&gt; 2、将我们的所有业务类，注入到Spring，可以通过配置或注解实现 123&lt;bean id=&quot;BookserviceImpl&quot; class=&quot;com.yyp.service.BookserviceImpl&quot;&gt; &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;/&gt;&lt;/bean&gt; 3、声明事务配置 1234&lt;bean id=&quot;transactionManage&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; 这一步可能会出错，原因是你没有将这几个容器（xml配置文件）放在一些。最简单的解决的方法就是在applicationContext导入这些配置文件。在我们编写mvc的配置文件之后，我就不在提示了。 spring mvc的配置web.xml主要就是DispathchServlet 1234567891011121314&lt;!--DispatchServlet--&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 乱码处理 123456789101112&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; session这是有效时长 123&lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt; spring-mvc.xml1、注解驱动 1&lt;mvc:annotation-driven/&gt; 2、静态资源过滤 1&lt;mvc:default-servlet-handler/&gt; 3、扫描包：controller 1&lt;contest:component-scan base-package=&quot;com.yyp.controller&quot;/&gt; 4、视图解析器 1234&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt; 以上就是全部的准备工作，下面是业务，不在讲解，代码自己参考。controller1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Controller@RequestMapping(&quot;/book&quot;)public class BookController &#123; @Autowired @Qualifier(&quot;BookserviceImpl&quot;) private BookService bookService; //查询全部的书籍，并且返回到一个书籍展示页面 @RequestMapping(&quot;/allBook&quot;) public String list(Model model)&#123; List&lt;Books&gt; list = bookService.queryAllBook(); model.addAttribute(&quot;list&quot;,list); return &quot;allBook&quot;; &#125; //跳转到增加书籍页面 @RequestMapping(&quot;toAddBook&quot;) public String toAddPager()&#123; return &quot;addBook&quot;; &#125; //添加书籍的请求 @RequestMapping(&quot;addBook&quot;) public String addBook(Books books)&#123; bookService.addBook(books); return &quot;redirect:/book/allBook&quot;; &#125; //跳转到书籍页面 @RequestMapping(&quot;toUpdatePager&quot;) public String toUpdatePager(int id,Model model)&#123; Books books = bookService.queryBookByID(id); model.addAttribute(&quot;QBook&quot;,books); return &quot;updateBook&quot;; &#125; //修改书籍 @RequestMapping(&quot;/updateBook&quot;) public String updateBook(Books books)&#123; bookService.updateBook(books); return &quot;redirect:/book/allBook&quot;; &#125; //删除书籍 @RequestMapping(&quot;deleteBook&quot;) public String deleteBook(int id)&#123; bookService.deleteBookByID(id); return &quot;redirect:/book/allBook&quot;; &#125; //查询书籍 @RequestMapping(&quot;queryBook&quot;) public String queryBook(String queryBookName,Model model)&#123; Books books = bookService.queryBookByName(queryBookName); List&lt;Books&gt; list = new ArrayList&lt;Books&gt;(); list.add(books); if(books==null)&#123; list = bookService.queryAllBook(); model.addAttribute(&quot;error&quot;,&quot;未查到&quot;); &#125; model.addAttribute(&quot;list&quot;,list); return &quot;allBook&quot;; &#125;&#125; jsp页面index.jsp123456789101112131415161718192021222324252627282930&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;首页&lt;&#x2F;title&gt; &lt;style&gt; a&#123; text-decoration: none; color: #00ffe1; font-size: 18px; &#125; h3&#123; width: 180px; height: 38px; margin: 100px auto; text-align: center; line-height: 38px; background: deepskyblue; border-radius: 5px ; &#125; &lt;&#x2F;style&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;h3&gt;&lt;a href&#x3D;&quot;&#x2F;book&#x2F;allBook&quot;&gt;跳转书籍页面&lt;&#x2F;a&gt; &lt;&#x2F;h3&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; addBook.jsp1234567891011121314151617181920212223242526272829303132333435363738394041&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;添加书籍页面&lt;&#x2F;title&gt; &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;twitter-bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div class&#x3D;&quot;container&quot;&gt; &lt;div class&#x3D;&quot;row clearfix&quot;&gt; &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt; &lt;div class&#x3D;&quot;page-header&quot;&gt; &lt;small&gt;新增书记&lt;&#x2F;small&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;form action&#x3D;&quot;&#x2F;book&#x2F;addBook&quot; method&#x3D;&quot;post&quot;&gt; &lt;div class&#x3D;&quot;form-group&quot;&gt; &lt;label for&#x3D;&quot;bkname&quot;&gt;书籍名称&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; id&#x3D;&quot;bkname&quot; name&#x3D;&quot;bookName&quot; required&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;form-group&quot;&gt; &lt;label for&#x3D;&quot;bkcounts&quot;&gt;书籍数量&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; id&#x3D;&quot;bkcounts&quot; name&#x3D;&quot;bookCounts&quot; required&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;form-group&quot;&gt; &lt;label for&#x3D;&quot;detali&quot;&gt;书籍详情&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; id&#x3D;&quot;detali&quot; name&#x3D;&quot;detail&quot; required&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;form-group&quot;&gt; &lt;input type&#x3D;&quot;submit&quot; class&#x3D;&quot;form-control&quot; value&#x3D;&quot;添加&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;form&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; allBook.jsp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;书籍展示页面&lt;&#x2F;title&gt; &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;twitter-bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div class&#x3D;&quot;container&quot;&gt; &lt;div class&#x3D;&quot;row clearfix&quot;&gt; &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt; &lt;div class&#x3D;&quot;page-header&quot;&gt; &lt;small&gt;书籍列表——————显示所有书籍&lt;&#x2F;small&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;row&quot;&gt; &lt;div class&#x3D;&quot;col-md-4 column&quot;&gt; &lt;a class&#x3D;&quot;btn btn-primary&quot; href&#x3D;&quot;&#x2F;book&#x2F;toAddBook&quot;&gt;新增书籍&lt;&#x2F;a&gt; &lt;a class&#x3D;&quot;btn btn-primary&quot; href&#x3D;&quot;&#x2F;book&#x2F;allBook&quot;&gt;显示全部书籍&lt;&#x2F;a&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;col-md-4 column&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;form-inline&quot;&gt; &lt;form action&#x3D;&quot;&#x2F;book&#x2F;queryBook&quot; method&#x3D;&quot;post&quot; style&#x3D;&quot;float: right&quot;&gt; &lt;span style&#x3D;&quot;color: red&quot;&gt;$&#123;error&#125;&lt;&#x2F;span&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;queryBookName&quot; class&#x3D;&quot;form-control&quot; placeholder&#x3D;&quot;请输入要查询的书籍名称&quot;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;查询&quot; class&#x3D;&quot;btn btn-primary&quot;&gt; &lt;&#x2F;form&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;row clearfix&quot;&gt; &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt; &lt;table class&#x3D;&quot;table table-hover table-striper&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;书籍编号&lt;&#x2F;th&gt; &lt;th&gt;书籍名称&lt;&#x2F;th&gt; &lt;th&gt;书籍数量&lt;&#x2F;th&gt; &lt;th&gt;书籍详情&lt;&#x2F;th&gt; &lt;th&gt;操作&lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;%--书籍从数据库中查询出来，从这个list中便利出来：foreach--%&gt; &lt;tbody&gt; &lt;c:forEach var&#x3D;&quot;book&quot; items&#x3D;&quot;$&#123;list&#125;&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.bookID&#125;&lt;&#x2F;td&gt; &lt;td&gt;$&#123;book.bookName&#125;&lt;&#x2F;td&gt; &lt;td&gt;$&#123;book.bookCounts&#125;&lt;&#x2F;td&gt; &lt;td&gt;$&#123;book.detail&#125;&lt;&#x2F;td&gt; &lt;td&gt; &lt;a href&#x3D;&quot;&#x2F;book&#x2F;toUpdatePager?id&#x3D;$&#123;book.bookID&#125;&quot;&gt;修改&lt;&#x2F;a&gt; &amp;nbsp; | &amp;nbsp; &lt;a href&#x3D;&quot;&#x2F;book&#x2F;deleteBook?id&#x3D;$&#123;book.bookID&#125;&quot;&gt;删除&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;c:forEach&gt; &lt;&#x2F;tbody&gt; &lt;&#x2F;table&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; updateBook.jsp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: 27211 Date: 2021&#x2F;3&#x2F;16 Time: 22:48 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;修改书籍页面&lt;&#x2F;title&gt; &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;twitter-bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div class&#x3D;&quot;container&quot;&gt; &lt;div class&#x3D;&quot;row clearfix&quot;&gt; &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt; &lt;div class&#x3D;&quot;page-header&quot;&gt; &lt;small&gt;修改书记&lt;&#x2F;small&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;form action&#x3D;&quot;&#x2F;book&#x2F;updateBook&quot; method&#x3D;&quot;post&quot;&gt; &lt;%--id没有传送，前段传递隐藏域--%&gt; &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;bookID&quot; value&#x3D;&quot;$&#123;QBook.bookID&#125;&quot;&gt; &lt;div class&#x3D;&quot;form-group&quot;&gt; &lt;label for&#x3D;&quot;bkname&quot;&gt;书籍名称&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; id&#x3D;&quot;bkname&quot; name&#x3D;&quot;bookName&quot; required value&#x3D;&quot;$&#123;QBook.bookName&#125;&quot;&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;form-group&quot;&gt; &lt;label for&#x3D;&quot;bkcounts&quot;&gt;书籍数量&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; id&#x3D;&quot;bkcounts&quot; name&#x3D;&quot;bookCounts&quot; required value&#x3D;&quot;$&#123;QBook.bookCounts&#125;&quot;&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;form-group&quot;&gt; &lt;label for&#x3D;&quot;detali&quot;&gt;书籍详情&lt;&#x2F;label&gt; &lt;input type&#x3D;&quot;text&quot; class&#x3D;&quot;form-control&quot; id&#x3D;&quot;detali&quot; name&#x3D;&quot;detail&quot; required value&#x3D;&quot;$&#123;QBook.detail&#125;&quot;&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;form-group&quot;&gt; &lt;input type&#x3D;&quot;submit&quot; class&#x3D;&quot;form-control&quot; value&#x3D;&quot;修改&quot;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;form&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;","categories":[],"tags":[]}]